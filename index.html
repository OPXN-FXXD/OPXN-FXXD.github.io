<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>OPENFEED — P2P</title>
<style>
  :root{--brand:#0b5fff;--muted:#6b7280}
  body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#f7f8fb;color:#0b1220;min-height:100vh;display:flex;flex-direction:column}
  header{background:var(--brand);color:white;padding:0.9rem 1rem;position:sticky;top:0;z-index:20}
  .container{max-width:1000px;margin:1rem auto;padding:1rem;background:white;border-radius:10px;box-shadow:0 8px 30px rgba(11,95,255,0.06);flex:1;max-height:calc(100vh - 140px);overflow:auto}
  .grid{display:grid;grid-template-columns:1fr 320px;gap:1rem}
  input,textarea,select,button{font:inherit}
  .muted{color:var(--muted);font-size:0.9rem}
  .message{padding:0.6rem;border-bottom:1px solid #eee;border-radius:6px;margin-bottom:0.5rem;background:#fff}
  .btn{background:var(--brand);color:white;padding:0.5rem;border-radius:8px;border:0;cursor:pointer}
  .btn.ghost{background:#eef4ff;color:var(--brand);border:1px solid #cfe0ff}
  .like-btn{background:none;border:1px solid #e6e9ee;padding:0.25rem 0.5rem;border-radius:6px;cursor:pointer}
  .liked{background:#ffdce0;border-color:#ff9aa2}
  .lang-pill{display:inline-block;padding:0.15rem 0.4rem;border-radius:4px;border:1px solid #e6e9ee;margin-left:0.4rem;font-size:0.8rem}
  footer.nav{position:fixed;left:0;right:0;bottom:0;background:white;border-top:1px solid #eee;padding:0.5rem 0;display:flex;justify-content:center;gap:1rem;z-index:40}
  footer.nav button{width:120px;border-radius:999px}
  .top-private{background:#fff7f3;border-left:4px solid #ff9aa2;padding:0.6rem;border-radius:6px;margin-bottom:0.8rem}
  .hidden{display:none}
  .toast-wrap{position:fixed;right:16px;bottom:80px;z-index:9999;display:flex;flex-direction:column;gap:8px;max-width:320px}
  .toast{background:#111;color:white;padding:0.6rem 0.9rem;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.12);font-size:0.95rem}
  .toast.info{background:#0b5fff}
  .toast.success{background:#119a4b}
  .toast.warn{background:#ff8c42}
  .toast.err{background:#b91c1c}
  .file-list{max-height:180px;overflow:auto;border:1px solid #eee;padding:6px;border-radius:6px;background:#fafafa}
  .file-item{padding:6px;border-bottom:1px solid #eee;cursor:pointer}
  .file-item:hover{background:#eef4ff}
  @media (max-width:900px){ .grid{grid-template-columns:1fr} aside{order:2} }
</style>
<script src="https://cdn.jsdelivr.net/npm/gun/gun.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
</head>
<body>
<header><h1 style="margin:0">OPENFEED — P2P</h1></header>

<div class="container">
  <!-- FEED PAGE -->
  <div id="page-feed" class="page">
    <div class="grid">
      <main>
        <section class="muted" style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>Feed</strong></div>
          <div>
            <label class="muted">Filter:</label>
            <select id="filterLang" style="padding:0.3rem">
              <option value="all">All</option>
              <option value="en">English</option>
              <option value="de">Deutsch</option>
              <option value="fr">Français</option>
              <option value="ja">日本語</option>
              <option value="zh">中文</option>
              <option value="es">Español</option>
              <option value="ru">Русский</option>
            </select>
          </div>
        </section>

        <section style="margin-top:1rem">
          <div id="privateInboxArea" class="hidden">
            <h4>Private Nachrichten (für dich)</h4>
            <div id="privateInbox"></div>
          </div>

          <div id="feed" style="margin-top:0.8rem"></div>
        </section>
      </main>

      <aside>
        <section style="margin-bottom:1rem">
          <h4>Kurzanleitung</h4>
          <div class="muted">
            - Navigation unten: Feed / Profil / Posten.<br>
            - Private Nachrichten (E2E) erscheinen oben im Feed nur für dich.<br>
            - Likes & Sprache bleiben aktiv.<br>
            - Custom-Algorithmus: lege eine JS-Datei in dein GitHub-Repo (siehe Profil → GitHub-Algorithmen).
          </div>
        </section>

        <section style="margin-top:1rem">
          <h4>Suche Profil</h4>
          <input id="quickLookup" placeholder="username oder pub" style="width:100%;padding:0.5rem"><div style="margin-top:0.5rem"><button class="btn ghost" id="btnLookup">Lookup</button></div>
          <div id="lookupResult" style="margin-top:0.5rem" class="muted"></div>
        </section>
      </aside>
    </div>
  </div>

  <!-- PROFILE PAGE -->
  <div id="page-profile" class="page hidden">
    <div class="grid">
      <main>
        <section>
          <h3>Profil</h3>
          <div id="profileBox" class="muted">Nicht eingeloggt</div>
        </section>

        <section style="margin-top:1rem">
          <h4>Identität erstellen / laden</h4>
          <input id="userName" placeholder="Benutzername" style="width:100%;padding:0.5rem">
          <input id="userPass" placeholder="Passphrase (optional)" style="width:100%;padding:0.5rem;margin-top:0.5rem">
          <div style="display:flex;gap:0.5rem;margin-top:0.6rem">
            <button class="btn" id="btnCreateUser">Erstelle Identität</button>
            <button class="btn ghost" id="btnLoginUser">Lade Identität</button>
          </div>
        </section>

        <section style="margin-top:1rem">
          <h4>Sprache & Export</h4>
          <label class="muted">Bevorzugte Sprache</label>
          <select id="profileLang" style="width:100%;padding:0.5rem;margin-top:0.3rem">
            <option value="en">English</option>
            <option value="de">Deutsch</option>
            <option value="fr">Français</option>
            <option value="ja">日本語</option>
            <option value="zh">中文</option>
            <option value="es">Español</option>
            <option value="ru">Русский</option>
          </select>
          <div style="display:flex;gap:0.5rem;margin-top:0.6rem">
            <button class="btn" id="btnSaveLang">Speichern</button>
            <button class="btn ghost" id="btnExportProfile">Profil exportieren</button>
          </div>
        </section>

        <section style="margin-top:1rem">
          <h4>GitHub: Algorithmus laden (öffentliche Repo)</h4>
          <div class="muted">Gib Repo-Details ein (standardmäßig auf dein Pages-Repo gesetzt). Du kannst dann Dateien im Repo browsen und eine Algorithmus-JS-Datei laden.</div>
          <div style="margin-top:0.5rem;display:flex;gap:0.5rem">
            <input id="ghOwner" placeholder="Owner" value="OPXN-FXXD" style="padding:0.4rem">
            <input id="ghRepo" placeholder="Repo" value="OPXN-FXXD.github.io" style="padding:0.4rem">
            <input id="ghBranch" placeholder="Branch" value="main" style="padding:0.4rem;width:100px">
          </div>
          <div style="margin-top:0.5rem;display:flex;gap:0.5rem">
            <input id="ghPath" placeholder="Pfad (z. B. algos/)" style="padding:0.4rem">
            <button class="btn ghost" id="btnListFiles">List files</button>
          </div>
          <div class="file-list" id="ghFileList" style="margin-top:0.6rem"></div>
          <div style="margin-top:0.6rem;display:flex;gap:0.5rem">
            <button class="btn" id="btnLoadSelected">Load selected algorithm</button>
            <button class="btn ghost" id="btnClearAlgo">Clear algorithm</button>
          </div>
          <div id="ghStatus" class="muted" style="margin-top:0.4rem"></div>
        </section>

        <section style="margin-top:1rem">
          <h4>Custom Algorithm (Editor)</h4>
          <label class="muted">Du kannst auch einen Algorithmus hier editieren oder testen (wird im Worker ausgeführt)</label>
          <textarea id="customAlgo" rows="6" style="width:100%;padding:0.4rem;margin-top:0.4rem" placeholder="// function score(post, user, utils) { return ... }"></textarea>
          <div style="display:flex;gap:0.5rem;margin-top:0.5rem">
            <button class="btn ghost" id="btnSaveCustom">Save & Activate</button>
            <button class="btn ghost" id="btnTestCustom">Test on sample</button>
          </div>
          <div id="customAlgoStatus" class="muted" style="margin-top:0.4rem"></div>
        </section>

      </main>

      <aside>
        <section>
          <h4>Hinweise</h4>
          <div class="muted">
            - GitHub Lesezugriff funktioniert nur für öffentliche Repos ohne Token.<br>
            - Die geladene Datei sollte eine JS-Funktion enthalten, die einen numerischen Score zurückgibt (siehe Beispiele).<br>
            - Execution läuft im Web Worker mit Timeout (sicherer als direktes eval).
          </div>
        </section>
      </aside>
    </div>
  </div>

  <!-- POST PAGE -->
  <div id="page-post" class="page hidden">
    <div class="grid">
      <main>
        <section>
          <h3>Posten</h3>
          <textarea id="postText" rows="5" style="width:100%;padding:0.6rem"></textarea>
          <div style="display:flex;gap:0.5rem;align-items:center;margin-top:0.6rem">
            <label class="muted">Sprache</label>
            <select id="postLang" style="padding:0.3rem;margin-left:0.3rem">
              <option value="en">English</option>
              <option value="de">Deutsch</option>
              <option value="fr">Français</option>
              <option value="ja">日本語</option>
              <option value="zh">中文</option>
              <option value="es">Español</option>
              <option value="ru">Русский</option>
            </select>

            <input id="postRecipient" placeholder="Empfänger (all oder username/pub)" style="flex:1;padding:0.4rem;margin-left:0.5rem">
            <button class="btn" id="btnPublish">Veröffentlichen</button>
          </div>
          <div id="postStatus" class="muted" style="margin-top:0.6rem"></div>
        </section>
      </main>

      <aside>
        <section>
          <h4>Private Nachricht</h4>
          <div class="muted">Wenn du als Empfänger einen PublicKey angibst oder einen existierenden username, wird die Nachricht E2E verschlüsselt und nur dem Empfänger zugänglich gemacht (erscheint dann oben im Feed für ihn).</div>
        </section>
      </aside>
    </div>
  </div>
</div>

<!-- bottom nav -->
<footer class="nav">
  <button id="navFeed" class="btn">Feed</button>
  <button id="navProfile" class="btn ghost">Profil</button>
  <button id="navPost" class="btn ghost">Posten</button>
</footer>

<!-- toast wrapper -->
<div class="toast-wrap" id="toasts"></div>

<script>
/* OPENFEED P2P — with GitHub algo loader
   - Fetches directory listings via GitHub API (public repos)
   - Loads raw files via raw.githubusercontent.com
   - Runs loaded algorithm code in Web Worker sandbox with timeout per scoring
   - Safe defaults and fallbacks present
*/

// -------------------- Utilities --------------------
const $ = id => document.getElementById(id);
function escapeHtml(s){ if(!s) return ''; return s.toString().replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;') }
function showToast(msg, kind='info', ttl=4000){
  const wrap = $('toasts');
  const el = document.createElement('div');
  el.className = 'toast ' + (kind==='info' ? 'info' : kind==='success' ? 'success' : kind==='warn' ? 'warn' : 'err');
  el.textContent = msg;
  wrap.appendChild(el);
  setTimeout(()=> { el.style.opacity = '0'; el.style.transform = 'translateX(20px)'; setTimeout(()=>el.remove(),400); }, ttl);
}

// -------------------- Gun setup --------------------
const gun = Gun({
  peers: [
    'https://gun-manhattan.herokuapp.com/gun',
    'https://gun-us.herokuapp.com/gun',
    'https://gun-eu.herokuapp.com/gun'
  ],
});
const postsNode = gun.get('openfeed_posts');
const profilesNode = gun.get('openfeed_profiles');
const likesNode = gun.get('likes_by_post');
const messagesNode = gun.get('openfeed_messages');

// -------------------- App state --------------------
let localUser = null; // { username, pair, lang }
const postsStore = {}; // id -> post
const inboxStore = []; // decrypted private messages

// -------------------- SPA Navigation --------------------
function showPage(pageId){
  document.querySelectorAll('.page').forEach(p=>p.classList.add('hidden'));
  $(pageId).classList.remove('hidden');
  $('navFeed').classList.toggle('btn', pageId==='page-feed');
  $('navFeed').classList.toggle('ghost', pageId!=='page-feed');
  $('navProfile').classList.toggle('btn', pageId==='page-profile');
  $('navProfile').classList.toggle('ghost', pageId!=='page-profile');
  $('navPost').classList.toggle('btn', pageId==='page-post');
  $('navPost').classList.toggle('ghost', pageId!=='page-post');
}
$('navFeed').addEventListener('click', ()=> showPage('page-feed'));
$('navProfile').addEventListener('click', ()=> showPage('page-profile'));
$('navPost').addEventListener('click', ()=> showPage('page-post'));
showPage('page-feed');

// -------------------- Identity & Profile --------------------
async function createIdentity(username, passphrase){
  if(!username){ showToast('Benutzername benötigt', 'warn'); return; }
  const pair = passphrase ? await SEA.pair(passphrase) : await SEA.pair();
  localUser = { username, pair, lang: $('profileLang').value || 'en' };
  try { localStorage.setItem('openfeed_user', JSON.stringify(localUser)); } catch(e){ console.error(e); }
  const profile = { username, pub: pair.pub, lang: localUser.lang, createdAt: new Date().toISOString() };
  profilesNode.get(username).put(profile);
  renderProfile(profile);
  watchInbox();
  showToast('Identität erstellt', 'success');
  return profile;
}

function loadIdentity(){
  const raw = localStorage.getItem('openfeed_user');
  if(!raw) return null;
  try{
    const parsed = JSON.parse(raw);
    if(!parsed.pair || !parsed.pair.pub){ showToast('Lokale Identität ungültig', 'err'); return null; }
    localUser = parsed;
    $('profileLang').value = localUser.lang || 'en';
    renderProfile({ username: localUser.username, pub: localUser.pair.pub, lang: localUser.lang });
    watchInbox();
    showToast('Identität geladen', 'info');
    return localUser;
  } catch(e){ console.error(e); showToast('Fehler beim Laden der Identität', 'err'); return null; }
}

function renderProfile(profile){
  $('profileBox').innerHTML = `<div><strong>${escapeHtml(profile.username)}</strong></div>
    <div class="muted" style="margin-top:0.3rem">PubKey: ${escapeHtml(profile.pub)}</div>
    <div class="muted" style="margin-top:0.3rem">Sprache: ${escapeHtml(profile.lang || 'en')}</div>`;
}

$('btnCreateUser').addEventListener('click', async ()=> {
  await createIdentity($('userName').value.trim(), $('userPass').value || null);
});
$('btnLoginUser').addEventListener('click', ()=> {
  const ok = loadIdentity();
  if(!ok) showToast('Keine Profil-Info im Browser gefunden', 'warn');
});

$('btnSaveLang').addEventListener('click', ()=>{
  if(!localUser) return showToast('Bitte erst Identität erstellen / laden', 'warn');
  localUser.lang = $('profileLang').value;
  localStorage.setItem('openfeed_user', JSON.stringify(localUser));
  profilesNode.get(localUser.username).put({ username: localUser.username, pub: localUser.pair.pub, lang: localUser.lang, updatedAt: new Date().toISOString() });
  renderProfile({ username: localUser.username, pub: localUser.pair.pub, lang: localUser.lang });
  showToast('Sprache gespeichert', 'success');
});

$('btnExportProfile').addEventListener('click', ()=>{
  if(!localUser) return showToast('Keine Identität vorhanden', 'warn');
  const out = { username: localUser.username, pub: localUser.pair.pub, lang: localUser.lang || 'en', createdAt: new Date().toISOString() };
  const blob = new Blob([JSON.stringify(out, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = `${out.username}.openfeed.profile.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  showToast('Profil JSON heruntergeladen', 'info');
});

// quick lookup
$('btnLookup').addEventListener('click', ()=>{
  const id = $('quickLookup').value.trim();
  if(!id) return showToast('Bitte Eingabe', 'warn');
  if(id.length>40 || id.indexOf('=')>-1){ $('lookupResult').textContent = 'Looks like a public key: ' + id; return; }
  profilesNode.get(id).once(v=>{
    if(v) $('lookupResult').textContent = `Found: ${v.username} (pub ${v.pub}), lang=${v.lang || 'en'}`; else $('lookupResult').textContent = 'Nicht gefunden';
  });
});

// -------------------- Posting --------------------
$('btnPublish').addEventListener('click', async ()=>{
  const text = $('postText').value.trim(); if(!text) return showToast('Bitte Text eingeben', 'warn');
  const lang = $('postLang').value || 'en';
  const recipient = $('postRecipient').value.trim() || 'all';
  const id = 'p' + Date.now() + Math.random().toString(36).slice(2,8);
  let authorName = 'anonym', authorPub = null;
  if(localUser){ authorName = localUser.username; authorPub = localUser.pair.pub; }
  const base = { id, authorName, authorPub, lang, time: Date.now() };

  if(recipient === 'all' || recipient === '') {
    const obj = Object.assign({}, base, { text, recipient:'all', public:true });
    postsNode.get(id).put(obj);
    showToast('Öffentlicher Post veröffentlicht', 'success');
  } else {
    const pub = await resolveRecipient(recipient);
    if(pub){
      if(!localUser) return showToast('Nur eingeloggte Nutzer können private verschlüsselte Posts senden', 'warn');
      try{
        const secret = await SEA.secret(pub, localUser.pair);
        const cipher = await SEA.encrypt(text, secret);
        const msg = { id: 'm' + Date.now() + Math.random().toString(36).slice(2,6), from: localUser.username, fromPub: localUser.pair.pub, payload: cipher, time: Date.now() };
        messagesNode.get(pub).get(msg.id).put(msg);
        showToast('Verschlüsselte Nachricht gesendet', 'success');
      } catch(e){ console.error(e); showToast('Fehler beim Verschlüsseln', 'err'); }
    } else {
      const obj = Object.assign({}, base, { text, recipient, public:false });
      postsNode.get(id).put(obj);
      showToast('Post erstellt (Privat-Label) — Empfänger nicht aufgelöst; kein E2E', 'warn');
    }
  }
  $('postText').value=''; $('postRecipient').value='';
});

// -------------------- Likes --------------------
async function toggleLike(postId){
  if(!localUser) return showToast('Bitte einloggen um zu liken', 'warn');
  const myPub = localUser.pair.pub;
  const node = likesNode.get(postId);
  node.get(myPub).once((v,k)=>{
    if(v){ node.get(myPub).put(null); showToast('Like entfernt', 'info'); }
    else { node.get(myPub).put(true); showToast('Gefällt mir', 'success'); }
  });
}

function observeLikesForPost(postId, cb){
  const node = likesNode.get(postId);
  const update = () => {
    const s = new Set();
    node.map().once((v,k)=>{ if(v) s.add(k); });
    setTimeout(()=> cb(Array.from(s)), 250);
  };
  node.map().on(()=> update());
  update();
}

// -------------------- Feed rendering & ranking --------------------
function langName(code){
  switch(code){
    case 'en': return 'EN';
    case 'de': return 'DE';
    case 'fr': return 'FR';
    case 'ja': return 'JP';
    case 'zh': return 'ZH';
    case 'es': return 'ES';
    case 'ru': return 'RU';
    default: return code;
  }
}

// Simple weight-based algorithm (default)
function loadWeights(){
  try{ return JSON.parse(localStorage.getItem('openfeed_weights')) || { lang:1.0, recency:1.0, likes:1.0 }; } catch(e){ return { lang:1.0, recency:1.0, likes:1.0 }; }
}
function computeScoreDefault(post, user){
  const w = loadWeights();
  const langScore = (post.lang === (user && user.lang ? user.lang : 'en')) ? 1 : 0;
  const ageSec = (Date.now() - (post.time || Date.now())) / 1000;
  const recencyScore = Math.max(0, 1 - ageSec / (60*60*24));
  const likeCount = post._likeCount || 0;
  return w.lang * langScore + w.recency * recencyScore + w.likes * Math.log(1 + likeCount);
}

// -------------------- Custom algorithm via GitHub or editor --------------------
// Worker management
let algoWorker = null;
let algoCodeRaw = null; // code string loaded (from GitHub or textarea)
const WORKER_TIMEOUT_MS = 250; // per post scoring timeout
const MAX_POSTS_FOR_CUSTOM = 200; // cap scoring per render for custom algos

function createAlgoWorkerFromCode(codeStr){
  // codeStr should be function body or a function definition that returns score
  // We'll build worker that on 'score' message executes user function safely
  const workerSrc = `
    self.onmessage = function(ev){
      const data = ev.data;
      if(!data || data.cmd !== 'score') return;
      try {
        // userFuncSource is passed as string in data (but we saved it during creation too)
        // We'll create function as: const scoreFn = new Function('post','user','utils', userFuncSource);
        const fnSource = ${JSON.stringify(codeStr)};
        const scoreFn = new Function('post','user','utils', fnSource);
        // create safe utils
        const utils = {
          likes: function(p){ return (p._likeCount || 0); },
          ageSec: function(p){ return ((Date.now() - (p.time||Date.now()))/1000); },
          langMatch: function(p,u){ return (p.lang === (u && u.lang ? u.lang : 'en') ? 1 : 0); }
        };
        const score = scoreFn(data.post, data.user, utils);
        self.postMessage({ ok: true, score: Number(score) || 0 });
      } catch(e){
        self.postMessage({ ok: false, error: String(e) });
      }
    };
  `;
  const blob = new Blob([workerSrc], { type: 'text/javascript' });
  const worker = new Worker(URL.createObjectURL(blob));
  return worker;
}

async function computeScoresWithWorker(posts){
  if(!algoCodeRaw) return posts.map(p => ({ id: p.id, score: computeScoreDefault(p, localUser) }));
  if(!algoWorker) algoWorker = createAlgoWorkerFromCode(algoCodeRaw);
  const limited = posts.slice(0, MAX_POSTS_FOR_CUSTOM);
  // compute in parallel with promises
  const promises = limited.map(p => new Promise(resolve => {
    let done = false;
    const onmsg = (ev) => {
      done = true;
      algoWorker.removeEventListener('message', onmsg);
      resolve({ id: p.id, score: ev.data && ev.data.ok ? ev.data.score : -99999 });
    };
    algoWorker.addEventListener('message', onmsg);
    // send post & user (simple snapshot)
    try{
      algoWorker.postMessage({ cmd:'score', post: { id:p.id, lang:p.lang, time:p.time, _likeCount:p._likeCount||0, text: p.text }, user: { username: localUser ? localUser.username : null, lang: localUser ? localUser.lang : 'en' } });
    } catch(e){
      algoWorker.removeEventListener('message', onmsg);
      resolve({ id: p.id, score: -99999 });
    }
    // timeout fallback
    setTimeout(()=>{ if(!done){ algoWorker.removeEventListener('message', onmsg); resolve({ id: p.id, score: -99999 }); } }, WORKER_TIMEOUT_MS);
  }));
  const res = await Promise.all(promises);
  // fill defaults for remaining posts (if any)
  if(posts.length > limited.length){
    const rest = posts.slice(limited.length).map(p => ({ id: p.id, score: computeScoreDefault(p, localUser) }));
    return res.concat(rest);
  }
  return res;
}

// Save / clear custom algorithm (raw code)
function saveCustomAlgo(code){
  algoCodeRaw = code;
  localStorage.setItem('openfeed_algo', code);
  if(algoWorker){ try{ algoWorker.terminate(); }catch(e){} algoWorker = null; }
}
function clearCustomAlgo(){
  algoCodeRaw = null;
  localStorage.removeItem('openfeed_algo');
  if(algoWorker){ algoWorker.terminate(); algoWorker = null; }
  showToast('Custom algorithm cleared', 'info');
}
function loadCustomAlgoFromStorage(){
  try{ const c = localStorage.getItem('openfeed_algo'); if(c) { algoCodeRaw = c; return c; } } catch(e){} return null;
}

// Editor button handlers
$('btnSaveCustom').addEventListener('click', ()=>{
  const code = $('customAlgo').value.trim();
  if(!code) return showToast('Kein Algorithmus eingegeben', 'warn');
  saveCustomAlgo(code);
  showToast('Custom algorithm saved (will be used for ranking)', 'success');
});
$('btnTestCustom').addEventListener('click', async ()=>{
  const code = $('customAlgo').value.trim();
  if(!code) return showToast('Kein Code zum Testen', 'warn');
  // try instantiate worker and run on small sample
  const worker = createAlgoWorkerFromCode(code);
  const samplePost = { id:'s1', lang:'en', time: Date.now(), _likeCount: 3, text:'Hello' };
  let ok = false;
  const onmsg = (ev) => {
    ok = ev.data && ev.data.ok;
    worker.terminate();
    showToast(ok ? ('Test OK — score=' + ev.data.score) : ('Test failed: ' + (ev.data.error||'unknown')), ok ? 'success' : 'err', 5000);
  };
  worker.addEventListener('message', onmsg);
  worker.postMessage({ cmd:'score', post: samplePost, user: { username: localUser ? localUser.username : null, lang: localUser ? localUser.lang : 'en' } });
  setTimeout(()=>{ if(!ok){ try{ worker.terminate(); }catch(e){} showToast('Test timeout or error', 'err'); } }, WORKER_TIMEOUT_MS + 50);
});

// try load existing algorithm on startup
loadCustomAlgoFromStorage();
if(algoCodeRaw){ $('customAlgo').value = algoCodeRaw; showToast('Custom algorithm loaded from storage', 'info'); }

// -------------------- GitHub: list files & load selected --------------------
async function githubListContents(owner, repo, path='', branch='main'){
  // GitHub API: GET /repos/{owner}/{repo}/contents/{path}?ref={branch}
  const apiUrl = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch)}`;
  try{
    const resp = await fetch(apiUrl);
    if(!resp.ok) throw new Error('GitHub API error: ' + resp.status);
    const json = await resp.json();
    // json is array for directory, object for file
    return json;
  } catch(e){
    throw e;
  }
}

function renderFileList(items){
  const list = $('ghFileList');
  list.innerHTML = '';
  if(!Array.isArray(items) || items.length===0){ list.innerHTML = '<div class="muted">Keine Dateien gefunden</div>'; return; }
  items.forEach(it=>{
    const div = document.createElement('div'); div.className='file-item';
    div.textContent = it.path || it.name;
    div.dataset.path = it.path || it.name;
    div.dataset.type = it.type || 'file';
    div.addEventListener('click', ()=> {
      // mark selected
      list.querySelectorAll('.file-item').forEach(x=>x.style.background='');
      div.style.background = '#e6f0ff';
      list.dataset.selected = div.dataset.path;
    });
    list.appendChild(div);
  });
}

// List files button
$('btnListFiles').addEventListener('click', async ()=>{
  const owner = $('ghOwner').value.trim();
  const repo = $('ghRepo').value.trim();
  const branch = $('ghBranch').value.trim() || 'main';
  const path = $('ghPath').value.trim().replace(/^\/+/,'').replace(/\/+$/,''); // normalize
  if(!owner || !repo) return showToast('Owner und Repo angeben', 'warn');
  $('ghStatus').textContent = 'Listing...';
  try{
    const result = await githubListContents(owner, repo, path || '', branch);
    // normalize to array
    const arr = Array.isArray(result) ? result : [result];
    // keep only JS files and directories
    const filtered = arr.filter(i => i.type === 'file' && (i.name.endsWith('.js') || i.name.endsWith('.mjs') || i.name.endsWith('.txt') || i.name.endsWith('.algo')) || i.type==='dir');
    renderFileList(filtered);
    $('ghStatus').textContent = 'Select a file to load (JS function expected)';
  } catch(e){
    console.error(e);
    showToast('Fehler beim Listen: ' + e.message, 'err', 6000);
    $('ghStatus').textContent = 'Fehler: ' + e.message;
  }
});

// Load selected file raw content
$('btnLoadSelected').addEventListener('click', async ()=>{
  const owner = $('ghOwner').value.trim();
  const repo = $('ghRepo').value.trim();
  const branch = $('ghBranch').value.trim() || 'main';
  const selected = $('ghFileList').dataset.selected;
  if(!owner || !repo || !selected) return showToast('Owner/Repo/Datei auswählen', 'warn');
  $('ghStatus').textContent = 'Lade Datei...';
  try{
    // construct raw URL: https://raw.githubusercontent.com/{owner}/{repo}/{branch}/{path}
    const rawUrl = `https://raw.githubusercontent.com/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/${encodeURIComponent(branch)}/${selected}`;
    const resp = await fetch(rawUrl);
    if(!resp.ok) throw new Error('Raw fetch failed: ' + resp.status);
    const content = await resp.text();
    // Basic safety: limit file size (e.g. 100 KB)
    if(content.length > 100*1024) { showToast('Datei zu groß', 'err'); $('ghStatus').textContent='File too large'; return; }
    // Save to editor & activate
    $('customAlgo').value = content;
    saveCustomAlgo(content);
    $('ghStatus').textContent = 'Algorithmus geladen und aktiviert';
    showToast('Algorithmus geladen (aus GitHub)', 'success');
  } catch(e){
    console.error(e);
    showToast('Fehler beim Laden: ' + e.message, 'err', 6000);
    $('ghStatus').textContent = 'Fehler: ' + e.message;
  }
});

// Clear algorithm
$('btnClearAlgo').addEventListener('click', ()=>{
  clearCustomAlgo();
  $('customAlgo').value = '';
  $('ghStatus').textContent = 'Custom algorithm cleared';
});

// -------------------- Messaging (E2E) --------------------
async function resolveRecipient(identifier){
  if(!identifier) return null;
  if(identifier.length>40 || identifier.indexOf('=')>-1) return identifier;
  return new Promise(resolve => {
    profilesNode.get(identifier).once(v=>{
      if(v && v.pub) resolve(v.pub); else resolve(null);
    });
  });
}

async function watchInbox(){
  inboxStore.length = 0;
  if(!localUser) return;
  const myPub = localUser.pair.pub;
  messagesNode.get(myPub).map().on(async (v,k)=>{
    if(!v || !v.payload) return;
    try{
      const secret = await SEA.secret(v.fromPub, localUser.pair);
      const plain = await SEA.decrypt(v.payload, secret);
      if(plain){
        if(!inboxStore.find(x=>x.id===v.id)){
          inboxStore.push({ id:v.id, from:v.from, fromPub:v.fromPub, text:plain, time:v.time || Date.now() });
          showToast('Neue private Nachricht von ' + v.from, 'info', 5000);
          renderFeed();
        }
      }
    } catch(err){
      console.error('decrypt error', err);
    }
  });
}

// -------------------- Posts subscription & likes wiring --------------------
// posts keyed get(id).put(...) is used; listen for map()
postsNode.map().on((v,k)=>{
  if(!v) return;
  const key = v.id || k;
  postsStore[key] = v;
  renderFeed();
});

// likes observation sets post._likeCount
function attachLikesCount(postId){
  observeLikesForPost(postId, (likesArray)=>{
    if(postsStore[postId]){ postsStore[postId]._likeCount = likesArray.length; renderFeed(); }
  });
}

// -------------------- Feed renderer using custom algorithm if present --------------------
async function renderFeed(){
  // private inbox at top
  if(inboxStore.length && localUser){
    $('privateInboxArea').classList.remove('hidden');
    const ib = $('privateInbox'); ib.innerHTML = '';
    inboxStore.sort((a,b)=>b.time - a.time).forEach(m=>{
      const div = document.createElement('div'); div.className='top-private';
      div.innerHTML = `<div style="display:flex;justify-content:space-between"><strong>Privat von ${escapeHtml(m.from)}</strong><span class="muted">${new Date(m.time).toLocaleString()}</span></div>
                       <div style="margin-top:0.4rem">${escapeHtml(m.text)}</div>`;
      ib.appendChild(div);
    });
  } else {
    $('privateInboxArea').classList.add('hidden');
  }

  const arr = Object.values(postsStore).slice(); // copy
  // ensure like counts are attached & observe likes
  arr.forEach(p => { if(p && p.id) attachLikesCount(p.id); if(!p._likeCount) p._likeCount = p._likeCount || 0; });

  // compute scores: if custom algorithm present, use worker; otherwise default
  let scored = [];
  if(algoCodeRaw){
    try{
      scored = await computeScoresWithWorker(arr);
      const map = {}; scored.forEach(s=> map[s.id] = s.score);
      arr.forEach(p => p._score = map[p.id] || -99999);
    } catch(e){ console.error(e); showToast('Error running custom algo: '+e.message, 'err'); arr.forEach(p => p._score = computeScoreDefault(p, localUser)); }
  } else {
    arr.forEach(p => p._score = computeScoreDefault(p, localUser));
  }

  // sort by score desc then time
  arr.sort((a,b) => {
    if((b._score||0) !== (a._score||0)) return (b._score||0) - (a._score||0);
    return (b.time||0) - (a.time||0);
  });

  const filter = $('filterLang').value;
  const list = $('feed'); list.innerHTML = '';
  arr.forEach(post=>{
    if(filter !== 'all' && post.lang !== filter) return;
    if(post.public === false && localUser){
      if(post.authorPub !== (localUser.pair && localUser.pair.pub)) return;
    } else if(post.public === false && !localUser) return;

    const div = document.createElement('div'); div.className='message';
    const langLabel = `<span class="lang-pill">${escapeHtml(langName(post.lang || 'en'))}</span>`;
    const timeStr = post.time ? new Date(post.time).toLocaleString() : '';
    const author = escapeHtml(post.authorName || post.authorPub || 'anonym');
    const text = escapeHtml(post.text || '');
    const scoreLabel = post._score !== undefined ? `<span class="muted" style="margin-left:8px">score:${(Math.round((post._score||0)*100)/100)}</span>` : '';
    div.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div><strong>${author}</strong> ${langLabel}${scoreLabel}</div><div class="muted">${timeStr}</div></div>
      <div style="margin-top:0.4rem">${text}</div>
      <div style="margin-top:0.6rem;display:flex;gap:0.6rem;align-items:center">
        <button class="like-btn" data-id="${post.id}">❤ <span class="like-count" data-id="${post.id}">${post._likeCount||0}</span></button>
        <span class="muted">ID: ${escapeHtml(post.id)}</span>
      </div>`;
    list.appendChild(div);

    const likeBtn = div.querySelector('.like-btn');
    likeBtn.addEventListener('click', ()=> toggleLike(post.id));
    // observe likes updates already done in attachLikesCount -> renderFeed triggers again
  });
}

// small periodic re-render to reflect updates and new likes
setInterval(()=> renderFeed(), 2000);

// -------------------- Inbox & identity init ----------
function identityLoadedActions(){
  watchInbox();
  renderFeed();
}
if(localStorage.getItem('openfeed_user')) { if(loadIdentity()) identityLoadedActions(); }

// -------------------- Seed --------------------
(function seed(){
  if(!localStorage.getItem('openfeed_seeded')){
    const id = 'seed' + Date.now();
    const obj = { id, authorName:'TxT_swiss', authorPub:null, text:'Welcome to OPENFEED — multilingual P2P prototype. You can now load custom ranking algorithms from your GitHub repo.', lang:'en', time: Date.now(), public:true };
    postsNode.get(id).put(obj);
    localStorage.setItem('openfeed_seeded','1');
  }
})();
</script>
</body>
</html>
