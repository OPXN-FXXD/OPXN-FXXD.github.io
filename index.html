
<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>OPENFEED — P2P</title>
<style>
  :root{--brand:#0b5fff;--muted:#6b7280}
  body{font-family:system-ui,Segoe UI,Roboto,Arial;margin:0;background:#f7f8fb;color:#0b1220;min-height:100vh;display:flex;flex-direction:column}
  header{background:var(--brand);color:white;padding:0.9rem 1rem;position:sticky;top:0;z-index:20}
  .container{max-width:1000px;margin:1rem auto;padding:1rem;background:white;border-radius:10px;box-shadow:0 8px 30px rgba(11,95,255,0.06);flex:1;max-height:calc(100vh - 140px);overflow:auto}
  .grid{display:grid;grid-template-columns:1fr 320px;gap:1rem}
  input,textarea,select,button{font:inherit}
  .muted{color:var(--muted);font-size:0.9rem}
  .message{padding:0.6rem;border-bottom:1px solid #eee;border-radius:6px;margin-bottom:0.5rem;background:#fff}
  .btn{background:var(--brand);color:white;padding:0.5rem;border-radius:8px;border:0;cursor:pointer}
  .btn.ghost{background:#eef4ff;color:var(--brand);border:1px solid #cfe0ff}
  .like-btn{background:none;border:1px solid #e6e9ee;padding:0.25rem 0.5rem;border-radius:6px;cursor:pointer}
  .liked{background:#ffdce0;border-color:#ff9aa2}
  .lang-pill{display:inline-block;padding:0.15rem 0.4rem;border-radius:4px;border:1px solid #e6e9ee;margin-left:0.4rem;font-size:0.8rem}
  footer.nav{position:fixed;left:0;right:0;bottom:0;background:white;border-top:1px solid #eee;padding:0.5rem 0;display:flex;justify-content:center;gap:1rem;z-index:40}
  footer.nav button{width:120px;border-radius:999px}
  .top-private{background:#fff7f3;border-left:4px solid #ff9aa2;padding:0.6rem;border-radius:6px;margin-bottom:0.8rem}
  .hidden{display:none}
  .toast-wrap{position:fixed;right:16px;bottom:80px;z-index:9999;display:flex;flex-direction:column;gap:8px;max-width:320px}
  .toast{background:#111;color:white;padding:0.6rem 0.9rem;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.12);font-size:0.95rem}
  .toast.info{background:#0b5fff}
  .toast.success{background:#119a4b}
  .toast.warn{background:#ff8c42}
  .toast.err{background:#b91c1c}
  .file-list{max-height:180px;overflow:auto;border:1px solid #eee;padding:6px;border-radius:6px;background:#fafafa}
  .file-item{padding:6px;border-bottom:1px solid #eee;cursor:pointer}
  .file-item:hover{background:#eef4ff}
  @media (max-width:900px){ .grid{grid-template-columns:1fr} aside{order:2} }
</style>
<script src="https://cdn.jsdelivr.net/npm/gun/gun.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gun/sea.js"></script>
</head>
<body>
<header><h1 style="margin:0">OPENFEED — P2P</h1></header>

<div class="container">
  <!-- FEED PAGE -->
  <div id="page-feed" class="page">
    <div class="grid">
      <main>
        <section class="muted" style="display:flex;justify-content:space-between;align-items:center">
          <div><strong>Feed</strong></div>
          <div>
            <label class="muted">Filter:</label>
            <select id="filterLang" style="padding:0.3rem">
              <option value="all">All</option>
              <option value="en">English</option>
              <option value="de">Deutsch</option>
              <option value="fr">Français</option>
              <option value="ja">日本語</option>
              <option value="zh">中文</option>
              <option value="es">Español</option>
              <option value="ru">Русский</option>
            </select>
          </div>
        </section>

        <section style="margin-top:1rem">
          <div id="privateInboxArea" class="hidden">
            <h4>Private Nachrichten (für dich)</h4>
            <div id="privateInbox"></div>
          </div>

          <div id="feed" style="margin-top:0.8rem"></div>
        </section>
      </main>

      <aside>
        <section style="margin-bottom:1rem">
          <h4>Kurzanleitung</h4>
          <div class="muted">
            - Navigation unten: Feed / Profil / Posten.<br>
            - Private Nachrichten (E2E) erscheinen oben im Feed nur für dich.<br>
            - Likes & Sprache bleiben aktiv.<br>
            - Custom-Algorithmus: lege eine JS-Datei in dein GitHub-Repo (siehe Profil → GitHub-Algorithmen).
          </div>
        </section>

        <section style="margin-top:1rem">
          <h4>Suche Profil</h4>
          <input id="quickLookup" placeholder="username oder pub" style="width:100%;padding:0.5rem"><div style="margin-top:0.5rem"><button class="btn ghost" id="btnLookup">Lookup</button></div>
          <div id="lookupResult" style="margin-top:0.5rem" class="muted"></div>
        </section>
      </aside>
    </div>
  </div>

  <!-- PROFILE PAGE -->
  <div id="page-profile" class="page hidden">
    <div class="grid">
      <main>
        <section>
          <h3>Profil</h3>
          <div id="profileBox" class="muted">Nicht eingeloggt</div>
        </section>

        <section style="margin-top:1rem">
          <h4>Identität erstellen / laden</h4>
          <input id="userName" placeholder="Benutzername" style="width:100%;padding:0.5rem">
          <input id="userPass" placeholder="Passphrase (optional — schützt deinen Schlüssel im LocalStorage)" style="width:100%;padding:0.5rem;margin-top:0.5rem">
          <div style="display:flex;gap:0.5rem;margin-top:0.6rem">
            <button class="btn" id="btnCreateUser">Erstelle Identität</button>
            <button class="btn ghost" id="btnLoginUser">Lade Identität</button>
          </div>
        </section>

        <section style="margin-top:1rem">
          <h4>Sprache & Export</h4>
          <label class="muted">Bevorzugte Sprache</label>
          <select id="profileLang" style="width:100%;padding:0.5rem;margin-top:0.3rem">
            <option value="en">English</option>
            <option value="de">Deutsch</option>
            <option value="fr">Français</option>
            <option value="ja">日本語</option>
            <option value="zh">中文</option>
            <option value="es">Español</option>
            <option value="ru">Русский</option>
          </select>
          <div style="display:flex;gap:0.5rem;margin-top:0.6rem">
            <button class="btn" id="btnSaveLang">Speichern</button>
            <button class="btn ghost" id="btnExportProfile">Profil exportieren</button>
          </div>
        </section>

        <section style="margin-top:1rem">
          <h4>GitHub: Algorithmus laden (öffentliche Repo)</h4>
          <div class="muted">Gib Repo-Details ein (standardmäßig auf dein Pages-Repo gesetzt). Du kannst dann Dateien im Repo browsen und eine Algorithmus-JS-Datei laden.</div>
          <div style="margin-top:0.5rem;display:flex;gap:0.5rem">
            <input id="ghOwner" placeholder="Owner" value="OPXN-FXXD" style="padding:0.4rem">
            <input id="ghRepo" placeholder="Repo" value="OPXN-FXXD.github.io" style="padding:0.4rem">
            <input id="ghBranch" placeholder="Branch" value="main" style="padding:0.4rem;width:100px">
          </div>
          <div style="margin-top:0.5rem;display:flex;gap:0.5rem">
            <input id="ghPath" placeholder="Pfad (z. B. algos/)" style="padding:0.4rem">
            <button class="btn ghost" id="btnListFiles">List files</button>
          </div>
          <div class="file-list" id="ghFileList" style="margin-top:0.6rem"></div>
          <div style="margin-top:0.6rem;display:flex;gap:0.5rem">
            <button class="btn" id="btnLoadSelected">Load selected algorithm</button>
            <button class="btn ghost" id="btnClearAlgo">Clear algorithm</button>
          </div>
          <div id="ghStatus" class="muted" style="margin-top:0.4rem"></div>
        </section>

        <section style="margin-top:1rem">
          <h4>Custom Algorithm (Editor)</h4>
          <label class="muted">Du kannst auch einen Algorithmus hier editieren oder testen (wird im Worker ausgeführt)</label>
          <textarea id="customAlgo" rows="6" style="width:100%;padding:0.4rem;margin-top:0.4rem" placeholder="// function score(post, user, utils) { return ... }"></textarea>
          <div style="display:flex;gap:0.5rem;margin-top:0.5rem">
            <button class="btn ghost" id="btnSaveCustom">Save & Activate</button>
            <button class="btn ghost" id="btnTestCustom">Test on sample</button>
          </div>
          <div id="customAlgoStatus" class="muted" style="margin-top:0.4rem"></div>
        </section>

      </main>

      <aside>
        <section>
          <h4>Hinweise</h4>
          <div class="muted">
            - GitHub Lesezugriff funktioniert nur für öffentliche Repos ohne Token.<br>
            - Die geladene Datei sollte eine JS-Funktion enthalten, die einen numerischen Score zurückgibt (siehe Beispiele).<br>
            - Execution läuft im Web Worker mit Timeout (sicherer als direktes eval).<br>
            - Private Schlüssel werden nicht unverschlüsselt gespeichert (wenn Passphrase genutzt wird, verschlüsselt gespeichert).
          </div>
        </section>
      </aside>
    </div>
  </div>

  <!-- POST PAGE -->
  <div id="page-post" class="page hidden">
    <div class="grid">
      <main>
        <section>
          <h3>Posten</h3>
          <textarea id="postText" rows="5" style="width:100%;padding:0.6rem" maxlength="2000" placeholder="Max 2000 Zeichen"></textarea>
          <div style="display:flex;gap:0.5rem;align-items:center;margin-top:0.6rem">
            <label class="muted">Sprache</label>
            <select id="postLang" style="padding:0.3rem;margin-left:0.3rem">
              <option value="en">English</option>
              <option value="de">Deutsch</option>
              <option value="fr">Français</option>
              <option value="ja">日本語</option>
              <option value="zh">中文</option>
              <option value="es">Español</option>
              <option value="ru">Русский</option>
            </select>

            <input id="postRecipient" placeholder="Empfänger (all oder username/pub)" style="flex:1;padding:0.4rem;margin-left:0.5rem">
            <button class="btn" id="btnPublish">Veröffentlichen</button>
          </div>
          <div id="postStatus" class="muted" style="margin-top:0.6rem"></div>
        </section>
      </main>

      <aside>
        <section>
          <h4>Private Nachricht</h4>
          <div class="muted">Wenn du als Empfänger einen PublicKey angibst oder einen existierenden username, wird die Nachricht E2E verschlüsselt und nur dem Empfänger zugänglich gemacht (erscheint dann oben im Feed für ihn).</div>
        </section>
      </aside>
    </div>
  </div>
</div>

<!-- bottom nav -->
<footer class="nav">
  <button id="navFeed" class="btn">Feed</button>
  <button id="navProfile" class="btn ghost">Profil</button>
  <button id="navPost" class="btn ghost">Posten</button>
</footer>

<!-- toast wrapper -->
<div class="toast-wrap" id="toasts"></div>

<script>
/* OPENFEED P2P — Hardened version
   Security/robustness changes:
   - Do NOT store private SEA pair unencrypted. If a passphrase is provided, the pair is encrypted with WebCrypto (PBKDF2 + AES-GCM) and stored.
   - Correct use of SEA.pair(); safe worker timeouts; input size limits; file size checks; better error handling.
*/

// -------------------- Utilities --------------------
const $ = id => document.getElementById(id);
function escapeHtml(s){ if(!s) return ''; return s.toString().replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;').replaceAll("'",'&#39;') }
function showToast(msg, kind='info', ttl=4000){
  const wrap = $('toasts');
  const el = document.createElement('div');
  el.className = 'toast ' + (kind==='info' ? 'info' : kind==='success' ? 'success' : kind==='warn' ? 'warn' : 'err');
  el.textContent = msg;
  wrap.appendChild(el);
  setTimeout(()=> { el.style.opacity = '0'; el.style.transform = 'translateX(20px)'; setTimeout(()=>el.remove(),400); }, ttl);
}

// -------------------- WebCrypto helpers for encrypting the pair --------------------
const CRYPTO = window.crypto || window.msCrypto;
async function deriveKeyFromPassphrase(passphrase, saltHex){
  const enc = new TextEncoder();
  const passKey = await CRYPTO.subtle.importKey('raw', enc.encode(passphrase), {name:'PBKDF2'}, false, ['deriveKey']);
  const salt = saltHex ? hexToBuf(saltHex) : CRYPTO.getRandomValues(new Uint8Array(16));
  const key = await CRYPTO.subtle.deriveKey(
    { name: 'PBKDF2', salt, iterations: 150_000, hash: 'SHA-256' },
    passKey,
    { name: 'AES-GCM', length: 256 },
    true,
    ['encrypt','decrypt']
  );
  return { key, salt: bufToHex(salt) };
}
async function encryptJSON(obj, key){
  const iv = CRYPTO.getRandomValues(new Uint8Array(12));
  const plain = new TextEncoder().encode(JSON.stringify(obj));
  const ct = await CRYPTO.subtle.encrypt({ name:'AES-GCM', iv }, key, plain);
  return { iv: bufToHex(iv), ct: bufToHex(ct) };
}
async function decryptJSON(encObj, key){
  const iv = hexToBuf(encObj.iv);
  const ct = hexToBuf(encObj.ct);
  const plainBuf = await CRYPTO.subtle.decrypt({ name:'AES-GCM', iv }, key, ct);
  return JSON.parse(new TextDecoder().decode(plainBuf));
}
function bufToHex(b){ return Array.from(new Uint8Array(b)).map(x=>x.toString(16).padStart(2,'0')).join(''); }
function hexToBuf(hex){ const bytes = new Uint8Array(hex.length/2); for(let i=0;i<bytes.length;i++){ bytes[i]=parseInt(hex.substr(i*2,2),16); } return bytes; }

// -------------------- Gun setup --------------------
const gun = Gun({
  peers: [
    // public relay peers (can be changed). Keep a short list to reduce surface.
    'https://gun-manhattan.herokuapp.com/gun',
    'https://gun-us.herokuapp.com/gun'
  ],
});
const postsNode = gun.get('openfeed_posts');
const profilesNode = gun.get('openfeed_profiles');
const likesNode = gun.get('likes_by_post');
const messagesNode = gun.get('openfeed_messages');

// -------------------- App state --------------------
let localUser = null; // { username, pair (in-memory or decrypted), lang }
const postsStore = {}; // id -> post
const inboxStore = []; // decrypted private messages

// -------------------- SPA Navigation --------------------
function showPage(pageId){
  document.querySelectorAll('.page').forEach(p=>p.classList.add('hidden'));
  $(pageId).classList.remove('hidden');
  $('navFeed').classList.toggle('btn', pageId==='page-feed');
  $('navFeed').classList.toggle('ghost', pageId!=='page-feed');
  $('navProfile').classList.toggle('btn', pageId==='page-profile');
  $('navProfile').classList.toggle('ghost', pageId!=='page-profile');
  $('navPost').classList.toggle('btn', pageId==='page-post');
  $('navPost').classList.toggle('ghost', pageId!=='page-post');
}
$('navFeed').addEventListener('click', ()=> showPage('page-feed'));
$('navProfile').addEventListener('click', ()=> showPage('page-profile'));
$('navPost').addEventListener('click', ()=> showPage('page-post'));
showPage('page-feed');

// -------------------- Identity & Profile --------------------
// storage keys
const STORAGE_KEY_ENC = 'openfeed_user_enc_v1'; // encrypted pair + meta
const STORAGE_KEY_PUBONLY = 'openfeed_user_pub_v1'; // public-only cache (safe)
const STORAGE_KEY_SEED = 'openfeed_seeded';

async function createIdentity(username, passphrase){
  if(!username){ showToast('Benutzername benötigt', 'warn'); return; }
  const pair = await SEA.pair(); // correct usage
  localUser = { username, pair, lang: $('profileLang').value || 'en' };

  // store only public metadata in localStorage (safe)
  try { localStorage.setItem(STORAGE_KEY_PUBONLY, JSON.stringify({ username, pub: pair.pub, lang: localUser.lang, createdAt: new Date().toISOString() })); } catch(e){ console.warn('Could not persist public meta', e); }

  // if passphrase provided, encrypt private pair and store; otherwise keep pair in-memory only
  if(passphrase && passphrase.length >= 6){
    try{
      const { key, salt } = await deriveKeyFromPassphrase(passphrase);
      const enc = await encryptJSON(pair, key);
      const payload = { username, pub: pair.pub, salt, enc };
      localStorage.setItem(STORAGE_KEY_ENC, JSON.stringify(payload));
      showToast('Identität erstellt und verschlüsselt gespeichert', 'success');
    } catch(e){
      console.error(e); showToast('Fehler beim Speichern der Identität', 'err');
    }
  } else {
    showToast('Identität erstellt (nicht persistent — keine Passphrase)', 'info');
  }

  // publish profile (only public fields)
  const profile = { username, pub: pair.pub, lang: localUser.lang, createdAt: new Date().toISOString() };
  profilesNode.get(username).put(profile);
  renderProfile(profile);
  watchInbox();
  return profile;
}

// load identity: try encrypted storage first, else public-only (no private pair)
async function loadIdentityFromStorage(passphrase=null){
  try{
    const encRaw = localStorage.getItem(STORAGE_KEY_ENC);
    if(encRaw){
      if(!passphrase){ showToast('Passphrase benötigt um verschlüsselte Identität zu laden', 'warn'); return null; }
      const parsed = JSON.parse(encRaw);
      const { key } = await deriveKeyFromPassphrase(passphrase, parsed.salt);
      const pair = await decryptJSON(parsed.enc, key);
      localUser = { username: parsed.username, pair, lang: $('profileLang').value || 'en' };
      // update public-only meta
      try { localStorage.setItem(STORAGE_KEY_PUBONLY, JSON.stringify({ username: parsed.username, pub: pair.pub, lang: localUser.lang })); } catch(e){}
      renderProfile({ username: localUser.username, pub: pair.pub, lang: localUser.lang });
      watchInbox();
      showToast('Verschlüsselte Identität geladen', 'info');
      return localUser;
    } else {
      // try public-only meta
      const pubRaw = localStorage.getItem(STORAGE_KEY_PUBONLY);
      if(!pubRaw){ showToast('Keine gespeicherte Identität gefunden', 'warn'); return null; }
      const meta = JSON.parse(pubRaw);
      localUser = { username: meta.username, pair: null, lang: meta.lang || 'en' };
      renderProfile({ username: meta.username, pub: meta.pub, lang: meta.lang });
      showToast('Nur öffentliches Profil geladen (kein privater Schlüssel)', 'info');
      return localUser;
    }
  } catch(e){ console.error(e); showToast('Fehler beim Laden der Identität', 'err'); return null; }
}

function renderProfile(profile){
  $('profileBox').innerHTML = `<div><strong>${escapeHtml(profile.username)}</strong></div>
    <div class="muted" style="margin-top:0.3rem">PubKey: ${escapeHtml(profile.pub || '—')}</div>
    <div class="muted" style="margin-top:0.3rem">Sprache: ${escapeHtml(profile.lang || 'en')}</div>`;
}

$('btnCreateUser').addEventListener('click', async ()=> {
  await createIdentity($('userName').value.trim(), $('userPass').value || null);
});
$('btnLoginUser').addEventListener('click', async ()=> {
  const pass = $('userPass').value || null;
  const ok = await loadIdentityFromStorage(pass);
  if(!ok) showToast('Identität nicht geladen', 'warn');
});

$('btnSaveLang').addEventListener('click', ()=> {
  if(!localUser) return showToast('Bitte erst Identität erstellen / laden', 'warn');
  localUser.lang = $('profileLang').value;
  try { const pub = JSON.parse(localStorage.getItem(STORAGE_KEY_PUBONLY) || '{}'); pub.lang = localUser.lang; localStorage.setItem(STORAGE_KEY_PUBONLY, JSON.stringify(pub)); } catch(e){}
  profilesNode.get(localUser.username).put({ username: localUser.username, pub: localUser.pair ? localUser.pair.pub : (pub && pub.pub), lang: localUser.lang, updatedAt: new Date().toISOString() });
  renderProfile({ username: localUser.username, pub: localUser.pair ? localUser.pair.pub : '', lang: localUser.lang });
  showToast('Sprache gespeichert', 'success');
});

$('btnExportProfile').addEventListener('click', async ()=> {
  if(!localUser) return showToast('Keine Identität vorhanden', 'warn');
  const out = { username: localUser.username, pub: localUser.pair ? localUser.pair.pub : null, exportedAt: new Date().toISOString() };
  // if we have private pair in memory, include it in export (user intends)
  if(localUser.pair) out.pair = localUser.pair;
  const blob = new Blob([JSON.stringify(out, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = `${out.username}.openfeed.profile.json`; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  showToast('Profil JSON heruntergeladen', 'info');
});

// quick lookup
$('btnLookup').addEventListener('click', ()=> {
  const id = $('quickLookup').value.trim();
  if(!id) return showToast('Bitte Eingabe', 'warn');
  if(id.length>40 || id.indexOf('=')>-1){ $('lookupResult').textContent = 'Looks like a public key: ' + id; return; }
  profilesNode.get(id).once(v=>{
    if(v) $('lookupResult').textContent = `Found: ${v.username} (pub ${v.pub}), lang=${v.lang || 'en'}`; else $('lookupResult').textContent = 'Nicht gefunden';
  });
});

// -------------------- Posting --------------------
const MAX_POST_LENGTH = 2000;
$('btnPublish').addEventListener('click', async ()=> {
  const text = $('postText').value.trim();
  if(!text) return showToast('Bitte Text eingeben', 'warn');
  if(text.length > MAX_POST_LENGTH) return showToast('Text zu lang (max ' + MAX_POST_LENGTH + ' Zeichen)', 'warn');
  const lang = $('postLang').value || 'en';
  const recipient = $('postRecipient').value.trim() || 'all';
  const id = 'p' + Date.now() + Math.random().toString(36).slice(2,8);
  let authorName = 'anonym', authorPub = null;
  if(localUser && localUser.username) { authorName = localUser.username; authorPub = localUser.pair ? localUser.pair.pub : null; }

  const base = { id, authorName, authorPub, lang, time: Date.now() };

  if(recipient === 'all' || recipient === '') {
    const obj = Object.assign({}, base, { text, recipient:'all', public:true });
    postsNode.get(id).put(obj);
    showToast('Öffentlicher Post veröffentlicht', 'success');
  } else {
    const pub = await resolveRecipient(recipient);
    if(pub){
      if(!localUser || !localUser.pair) return showToast('Nur Nutzer mit geladenem priv. Schlüssel können private verschlüsselte Posts senden', 'warn');
      try{
        const secret = await SEA.secret(pub, localUser.pair);
        const cipher = await SEA.encrypt(text, secret);
        const msg = { id: 'm' + Date.now() + Math.random().toString(36).slice(2,6), from: localUser.username, fromPub: localUser.pair.pub, payload: cipher, time: Date.now() };
        messagesNode.get(pub).get(msg.id).put(msg);
        showToast('Verschlüsselte Nachricht gesendet', 'success');
      } catch(e){ console.error(e); showToast('Fehler beim Verschlüsseln', 'err'); }
    } else {
      const obj = Object.assign({}, base, { text, recipient, public:false });
      postsNode.get(id).put(obj);
      showToast('Post erstellt (Privat-Label) — Empfänger nicht aufgelöst; kein E2E', 'warn');
    }
  }
  $('postText').value=''; $('postRecipient').value='';
});

// -------------------- Likes --------------------
async function toggleLike(postId){
  if(!localUser || !localUser.pair) return showToast('Bitte einloggen (Schlüssel geladen), um zu liken', 'warn');
  const myPub = localUser.pair.pub;
  const node = likesNode.get(postId);
  node.get(myPub).once((v,k)=>{
    if(v){ node.get(myPub).put(null); showToast('Like entfernt', 'info'); }
    else { node.get(myPub).put(true); showToast('Gefällt mir', 'success'); }
  });
}

function observeLikesForPost(postId, cb){
  const node = likesNode.get(postId);
  const update = () => {
    const s = new Set();
    node.map().once((v,k)=>{ if(v) s.add(k); });
    setTimeout(()=> cb(Array.from(s)), 250);
  };
  node.map().on(()=> update());
  update();
}

// -------------------- Feed ranking & default algorithm --------------------
function langName(code){
  switch(code){
    case 'en': return 'EN';
    case 'de': return 'DE';
    case 'fr': return 'FR';
    case 'ja': return 'JP';
    case 'zh': return 'ZH';
    case 'es': return 'ES';
    case 'ru': return 'RU';
    default: return code;
  }
}

function loadWeights(){
  try{ return JSON.parse(localStorage.getItem('openfeed_weights')) || { lang:1.0, recency:1.0, likes:1.0 }; } catch(e){ return { lang:1.0, recency:1.0, likes:1.0 }; }
}
function computeScoreDefault(post, user){
  const w = loadWeights();
  const langScore = (post.lang === (user && user.lang ? user.lang : 'en')) ? 1 : 0;
  const ageSec = (Date.now() - (post.time || Date.now())) / 1000;
  const recencyScore = Math.max(0, 1 - ageSec / (60*60*24));
  const likeCount = post._likeCount || 0;
  return w.lang * langScore + w.recency * recencyScore + w.likes * Math.log(1 + likeCount);
}

// -------------------- Custom algorithm via GitHub or editor --------------------
let algoWorker = null;
let algoCodeRaw = null;
const WORKER_TIMEOUT_MS = 500;
const MAX_POSTS_FOR_CUSTOM = 200;
const MAX_ALGO_LENGTH = 100 * 1024; // 100 KB

function createAlgoWorkerFromCode(codeStr){
  // Build worker that constructs function from provided source but with safety wrappers
  const workerSrc = `
    self.onmessage = function(ev){
      const data = ev.data;
      if(!data || data.cmd !== 'score') return;
      try {
        const userFuncSrc = ${JSON.stringify(codeStr)};
        // create function with (post,user,utils) signature
        const scoreFn = new Function('post','user','utils', userFuncSrc);
        const utils = {
          likes: function(p){ return (p._likeCount || 0); },
          ageSec: function(p){ return ((Date.now() - (p.time||Date.now()))/1000); },
          langMatch: function(p,u){ return (p.lang === (u && u.lang ? u.lang : 'en') ? 1 : 0); }
        };
        // run
        const score = scoreFn(data.post, data.user, utils);
        self.postMessage({ ok: true, score: Number(score) || 0 });
      } catch(e){
        self.postMessage({ ok: false, error: String(e) });
      }
    };
  `;
  const blob = new Blob([workerSrc], { type: 'text/javascript' });
  const worker = new Worker(URL.createObjectURL(blob));
  return worker;
}

async function computeScoresWithWorker(posts){
  if(!algoCodeRaw) return posts.map(p => ({ id: p.id, score: computeScoreDefault(p, localUser) }));
  if(!algoWorker) algoWorker = createAlgoWorkerFromCode(algoCodeRaw);
  const limited = posts.slice(0, MAX_POSTS_FOR_CUSTOM);
  const promises = limited.map(p => new Promise(resolve => {
    let done = false;
    const onmsg = (ev) => {
      done = true;
      algoWorker.removeEventListener('message', onmsg);
      resolve({ id: p.id, score: ev.data && ev.data.ok ? ev.data.score : -99999 });
    };
    algoWorker.addEventListener('message', onmsg);
    // snapshot to avoid sending heavy objects
    try{
      algoWorker.postMessage({ cmd:'score', post: { id:p.id, lang:p.lang, time:p.time, _likeCount:p._likeCount||0, text: p.text }, user: { username: localUser ? localUser.username : null, lang: localUser ? localUser.lang : 'en' } });
    } catch(e){
      algoWorker.removeEventListener('message', onmsg);
      resolve({ id: p.id, score: -99999 });
    }
    setTimeout(()=>{ if(!done){ try{ algoWorker.terminate(); }catch(e){} algoWorker = null; resolve({ id: p.id, score: -99999 }); } }, WORKER_TIMEOUT_MS);
  }));
  const res = await Promise.all(promises);
  if(posts.length > limited.length){
    const rest = posts.slice(limited.length).map(p => ({ id: p.id, score: computeScoreDefault(p, localUser) }));
    return res.concat(rest);
  }
  return res;
}

function saveCustomAlgo(code){
  if(!code || code.length > MAX_ALGO_LENGTH) { showToast('Algorithmus fehlt oder zu groß', 'warn'); return; }
  algoCodeRaw = code;
  localStorage.setItem('openfeed_algo', code);
  if(algoWorker){ try{ algoWorker.terminate(); }catch(e){} algoWorker = null; }
}
function clearCustomAlgo(){
  algoCodeRaw = null;
  localStorage.removeItem('openfeed_algo');
  if(algoWorker){ algoWorker.terminate(); algoWorker = null; }
  showToast('Custom algorithm cleared', 'info');
}
function loadCustomAlgoFromStorage(){
  try{ const c = localStorage.getItem('openfeed_algo'); if(c) { algoCodeRaw = c; return c; } } catch(e){} return null;
}

$('btnSaveCustom').addEventListener('click', ()=> {
  const code = $('customAlgo').value.trim();
  if(!code) return showToast('Kein Algorithmus eingegeben', 'warn');
  if(code.length > MAX_ALGO_LENGTH) return showToast('Algorithmus zu gross', 'warn');
  saveCustomAlgo(code);
  showToast('Custom algorithm saved (wird für Ranking verwendet)', 'success');
});
$('btnTestCustom').addEventListener('click', async ()=> {
  const code = $('customAlgo').value.trim();
  if(!code) return showToast('Kein Code zum Testen', 'warn');
  const worker = createAlgoWorkerFromCode(code);
  const samplePost = { id:'s1', lang:'en', time: Date.now(), _likeCount: 3, text:'Hello' };
  let done = false;
  const onmsg = (ev) => {
    done = true;
    worker.terminate();
    showToast(ev.data && ev.data.ok ? ('Test OK — score=' + ev.data.score) : ('Test failed: ' + (ev.data.error||'unknown')), ev.data && ev.data.ok ? 'success' : 'err', 5000);
  };
  worker.addEventListener('message', onmsg);
  try{
    worker.postMessage({ cmd:'score', post: samplePost, user: { username: localUser ? localUser.username : null, lang: localUser ? localUser.lang : 'en' } });
  } catch(e){ worker.terminate(); showToast('Fehler beim Test', 'err'); }
  setTimeout(()=>{ if(!done){ try{ worker.terminate(); }catch(e){} showToast('Test timeout or error', 'err'); } }, WORKER_TIMEOUT_MS + 100);
});

// try load existing algorithm on startup
loadCustomAlgoFromStorage();
if(algoCodeRaw){ $('customAlgo').value = algoCodeRaw; showToast('Custom algorithm loaded from storage', 'info'); }

// -------------------- GitHub: list files & load selected --------------------
async function githubListContents(owner, repo, path='', branch='main'){
  const apiUrl = `https://api.github.com/repos/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/contents/${encodeURIComponent(path)}?ref=${encodeURIComponent(branch)}`;
  const resp = await fetch(apiUrl, { headers: { 'Accept': 'application/vnd.github.v3+json' }});
  if(!resp.ok) throw new Error('GitHub API error: ' + resp.status);
  return await resp.json();
}

function renderFileList(items){
  const list = $('ghFileList');
  list.innerHTML = '';
  if(!Array.isArray(items) || items.length===0){ list.innerHTML = '<div class="muted">Keine Dateien gefunden</div>'; return; }
  items.forEach(it=>{
    // only show files and dirs
    if(!it || (!it.type)) return;
    const allowed = (it.type === 'file' && (it.name.endsWith('.js') || it.name.endsWith('.mjs') || it.name.endsWith('.algo') || it.name.endsWith('.txt'))) || it.type === 'dir';
    if(!allowed) return;
    const div = document.createElement('div'); div.className='file-item';
    div.textContent = it.path || it.name;
    div.dataset.path = it.path || it.name;
    div.dataset.type = it.type || 'file';
    div.addEventListener('click', ()=> {
      list.querySelectorAll('.file-item').forEach(x=>x.style.background='');
      div.style.background = '#e6f0ff';
      list.dataset.selected = div.dataset.path;
    });
    list.appendChild(div);
  });
}

$('btnListFiles').addEventListener('click', async ()=> {
  const owner = $('ghOwner').value.trim();
  const repo = $('ghRepo').value.trim();
  const branch = $('ghBranch').value.trim() || 'main';
  const path = $('ghPath').value.trim().replace(/^\/+/,'').replace(/\/+$/,'');
  if(!owner || !repo) return showToast('Owner und Repo angeben', 'warn');
  $('ghStatus').textContent = 'Listing...';
  try{
    const result = await githubListContents(owner, repo, path || '', branch);
    const arr = Array.isArray(result) ? result : [result];
    renderFileList(arr);
    $('ghStatus').textContent = 'Select a file to load (JS function expected)';
  } catch(e){
    console.error(e);
    showToast('Fehler beim Listen: ' + e.message, 'err', 6000);
    $('ghStatus').textContent = 'Fehler: ' + e.message;
  }
});

$('btnLoadSelected').addEventListener('click', async ()=> {
  const owner = $('ghOwner').value.trim();
  const repo = $('ghRepo').value.trim();
  const branch = $('ghBranch').value.trim() || 'main';
  const selected = $('ghFileList').dataset.selected;
  if(!owner || !repo || !selected) return showToast('Owner/Repo/Datei auswählen', 'warn');
  $('ghStatus').textContent = 'Lade Datei...';
  try{
    const rawUrl = `https://raw.githubusercontent.com/${encodeURIComponent(owner)}/${encodeURIComponent(repo)}/${encodeURIComponent(branch)}/${selected}`;
    const resp = await fetch(rawUrl);
    if(!resp.ok) throw new Error('Raw fetch failed: ' + resp.status);
    const contentLength = resp.headers.get('content-length');
    if(contentLength && Number(contentLength) > 100*1024){ showToast('Datei zu groß', 'err'); $('ghStatus').textContent='File too large'; return; }
    const content = await resp.text();
    if(content.length > 100*1024){ showToast('Datei zu groß', 'err'); $('ghStatus').textContent='File too large'; return; }
    $('customAlgo').value = content;
    saveCustomAlgo(content);
    $('ghStatus').textContent = 'Algorithmus geladen und aktiviert';
    showToast('Algorithmus geladen (aus GitHub)', 'success');
  } catch(e){
    console.error(e);
    showToast('Fehler beim Laden: ' + e.message, 'err', 6000);
    $('ghStatus').textContent = 'Fehler: ' + e.message;
  }
});

$('btnClearAlgo').addEventListener('click', ()=> {
  clearCustomAlgo();
  $('customAlgo').value = '';
  $('ghStatus').textContent = 'Custom algorithm cleared';
});

// -------------------- Messaging (E2E) --------------------
async function resolveRecipient(identifier){
  if(!identifier) return null;
  if(identifier.length>40 || identifier.indexOf('=')>-1) return identifier; // likely a pub key
  return new Promise(resolve => {
    profilesNode.get(identifier).once(v=>{ if(v && v.pub) resolve(v.pub); else resolve(null); });
  });
}

async function watchInbox(){
  inboxStore.length = 0;
  if(!localUser || !localUser.pair) return;
  const myPub = localUser.pair.pub;
  messagesNode.get(myPub).map().on(async (v,k)=>{
    if(!v || !v.payload) return;
    try{
      const secret = await SEA.secret(v.fromPub, localUser.pair);
      const plain = await SEA.decrypt(v.payload, secret);
      if(plain){
        if(!inboxStore.find(x=>x.id===v.id)){
          inboxStore.push({ id:v.id, from:v.from, fromPub:v.fromPub, text:plain, time:v.time || Date.now() });
          showToast('Neue private Nachricht von ' + v.from, 'info', 5000);
          renderFeed();
        }
      }
    } catch(err){
      console.error('decrypt error', err);
    }
  });
}

// -------------------- Posts subscription & likes wiring --------------------
postsNode.map().on((v,k)=>{
  if(!v) return;
  const key = v.id || k;
  postsStore[key] = v;
  renderFeed();
});

function attachLikesCount(postId){
  observeLikesForPost(postId, (likesArray)=>{
    if(postsStore[postId]){ postsStore[postId]._likeCount = likesArray.length; renderFeed(); }
  });
}

// -------------------- Feed renderer --------------------
async function renderFeed(){
  if(inboxStore.length && localUser && localUser.pair){
    $('privateInboxArea').classList.remove('hidden');
    const ib = $('privateInbox'); ib.innerHTML = '';
    inboxStore.sort((a,b)=>b.time - a.time).forEach(m=>{
      const div = document.createElement('div'); div.className='top-private';
      div.innerHTML = `<div style="display:flex;justify-content:space-between"><strong>Privat von ${escapeHtml(m.from)}</strong><span class="muted">${new Date(m.time).toLocaleString()}</span></div>
                       <div style="margin-top:0.4rem">${escapeHtml(m.text)}</div>`;
      ib.appendChild(div);
    });
  } else {
    $('privateInboxArea').classList.add('hidden');
  }

  const arr = Object.values(postsStore).slice();
  arr.forEach(p => { if(p && p.id) attachLikesCount(p.id); if(!p._likeCount) p._likeCount = p._likeCount || 0; });

  // compute scores
  let scored = [];
  if(algoCodeRaw){
    try{
      scored = await computeScoresWithWorker(arr);
      const map = {}; scored.forEach(s=> map[s.id] = s.score);
      arr.forEach(p => p._score = map[p.id] || -99999);
    } catch(e){ console.error(e); showToast('Error running custom algo: '+e.message, 'err'); arr.forEach(p => p._score = computeScoreDefault(p, localUser)); }
  } else {
    arr.forEach(p => p._score = computeScoreDefault(p, localUser));
  }

  arr.sort((a,b) => {
    if((b._score||0) !== (a._score||0)) return (b._score||0) - (a._score||0);
    return (b.time||0) - (a.time||0);
  });

  const filter = $('filterLang').value;
  const list = $('feed'); list.innerHTML = '';
  arr.forEach(post=>{
    if(filter !== 'all' && post.lang !== filter) return;
    if(post.public === false && localUser && post.authorPub){
      if(!localUser.pair || post.authorPub !== localUser.pair.pub) return;
    } else if(post.public === false && !localUser) return;

    const div = document.createElement('div'); div.className='message';
    const langLabel = `<span class="lang-pill">${escapeHtml(langName(post.lang || 'en'))}</span>`;
    const timeStr = post.time ? new Date(post.time).toLocaleString() : '';
    const author = escapeHtml(post.authorName || post.authorPub || 'anonym');
    const text = escapeHtml(post.text || '');
    const scoreLabel = post._score !== undefined ? `<span class="muted" style="margin-left:8px">score:${(Math.round((post._score||0)*100)/100)}</span>` : '';
    div.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center"><div><strong>${author}</strong> ${langLabel}${scoreLabel}</div><div class="muted">${timeStr}</div></div>
      <div style="margin-top:0.4rem">${text}</div>
      <div style="margin-top:0.6rem;display:flex;gap:0.6rem;align-items:center">
        <button class="like-btn" data-id="${post.id}">❤ <span class="like-count" data-id="${post.id}">${post._likeCount||0}</span></button>
        <span class="muted">ID: ${escapeHtml(post.id)}</span>
      </div>`;
    list.appendChild(div);

    const likeBtn = div.querySelector('.like-btn');
    likeBtn.addEventListener('click', ()=> toggleLike(post.id));
  });
}

// periodic re-render
setInterval(()=> renderFeed(), 2500);

// -------------------- Inbox & identity init ----------
function identityLoadedActions(){
  watchInbox();
  renderFeed();
}

(async function tryLoadPubMetaOnStart(){
  // try to show pub-only meta if present
  try{
    const pubRaw = localStorage.getItem(STORAGE_KEY_PUBONLY);
    if(pubRaw){ const meta = JSON.parse(pubRaw); renderProfile(meta); localUser = { username: meta.username, pair: null, lang: meta.lang }; showToast('Öffentliches Profil geladen', 'info'); }
    // try load encrypted identity only if user supplies passphrase (not automatically)
  } catch(e){ console.warn(e); }
})();

// -------------------- Seed --------------------
(function seed(){
  if(!localStorage.getItem(STORAGE_KEY_SEED)){
    const id = 'seed' + Date.now();
    const obj = { id, authorName:'TxT_swiss', authorPub:null, text:'Welcome to OPENFEED — multilingual P2P prototype. Load custom ranking algorithms from your GitHub repo.', lang:'en', time: Date.now(), public:true };
    postsNode.get(id).put(obj);
    localStorage.setItem(STORAGE_KEY_SEED,'1');
  }
})();
</script>
</body>
</html>
